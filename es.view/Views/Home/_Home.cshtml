@model es.view.Models.IndexViewModel
@{
    ViewBag.Title = "Latest Posts";
}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>@ViewBag.Title</title>
    <!-- Assuming Bootstrap is already included via your template -->
    <style>
        /* Additional custom styling */
        .post-card {
            position: relative;
            margin-bottom: 20px;
        }

        .post-number {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: #007bff;
            color: #fff;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }
    </style>
</head>
<body class="bg-light">
    <div class="container mt-5">
        <main aria-labelledby="title">
            <h2 id="title" class="text-center mb-4">@ViewBag.Title</h2>

            <!-- Container that will hold all of our loaded posts -->
            <div id="posts-container"></div>

            <!-- Loading indicator, shown when we are fetching data -->
            <div id="loading" class="text-center my-3" style="display: none;">Loading...</div>

            <!-- A sentinel element for IntersectionObserver to watch -->
            <div id="scroll-sentinel"></div>

            <!-- Displayed when there are no more posts to load -->
            <div id="no-more-posts" class="text-center my-3" style="display: none;">No more posts available.</div>
        </main>
    </div>

    <script>
        let page = 1;
        const pageSize = 5;
        let isLoading = false;
        let hasMorePosts = true;
        const loadedPostIds = new Set();
        let postCount = 0; // Count of posts loaded
        let currentWatchId = null;
        var youtubeIntervals = {};
        var watchSessions = {};

        const postsContainer = document.getElementById("posts-container");
        const loadingIndicator = document.getElementById("loading");
        const sentinel = document.getElementById("scroll-sentinel");
        const noMorePosts = document.getElementById("no-more-posts");

        /**
         * Fetches and appends posts from the server.
         */
        function loadPosts() {
            if (isLoading || !hasMorePosts) return;
            isLoading = true;
            loadingIndicator.style.display = "block";
            console.log(`Loading posts for page ${page}...`);

            const url = `/Home/GetPosts?page=${page}&pageSize=${pageSize}`;
            console.log("Fetching posts from:", url);

            fetch(url, { credentials: "include" })
                .then(response => {
                    console.log("HTTP status:", response.status);
                    return response.text();
                })
                .then(text => {
                    console.log("Raw response text:", text);
                    let data;
                    try {
                        data = JSON.parse(text);
                    } catch (e) {
                        console.error("Error parsing JSON:", e);
                        throw e;
                    }
                    return data;
                })
                .then(data => {
                    if (!data || data.length === 0) {
                        console.log("No more posts to load.");
                        hasMorePosts = false;
                        noMorePosts.style.display = "block";
                        if (observer) observer.disconnect();
                    } else {
                        console.log(`Received ${data.length} posts.`);
                        data.forEach(post => {
                            console.log("Processing post:", post);
                            // Using the JSON property 'ContentID', 'Title', and 'ContentBody'
                            if (!loadedPostIds.has(post.ContentID)) {
                                loadedPostIds.add(post.ContentID);
                                postCount++;
                                console.log(`Adding post ID ${post.ContentID}, Count: ${postCount}`);

                                // Check for a video embed if a ContentURL exists.
                                let videoEmbed = "";
                                if (post.ContentURL && post.ContentURL.trim() !== "") {
                                    let embedUrl = post.ContentURL;
                                    // If it's a YouTube URL and doesn't already have the parameter, add it.
                                    if (embedUrl.includes("youtube.com") && !embedUrl.includes("enablejsapi=1")) {
                                        embedUrl += (embedUrl.includes("?") ? "&" : "?") + "enablejsapi=1";
                                    }
                                    videoEmbed = `
                        <div
                            style="
                                position: relative;
                                width: 100%;
                                /* 16:9 aspect ratio => 9 / 16 = 56.25% */
                                padding-top: 56.25%;
                                border: 2px solid #ddd;
                                border-radius: 5px;
                                box-shadow: 0 4px 8px rgba(0,0,0,0.1);
                                overflow: hidden;
                                margin-bottom: 1rem;
                            "
                        >
                            <iframe
                                data-contentid="${post.ContentID}"
                                src="${embedUrl}"
                                allowfullscreen
                                style="
                                    position: absolute;
                                    top: 0;
                                    left: 0;
                                    width: 100%;
                                    height: 100%;
                                    border: 0;
                                "
                            >
                            </iframe>
                        </div>
                    `;
                                }

                                // If the FileData column is not NULL, create a download link using FileName.
                                let downloadLink = "";
                                if (post.FileName != null) {
                                    downloadLink = `<a href="/Home/DownloadFile?id=${post.ContentID}">${post.FileName}</a>`;
                                }

                                const postCard = document.createElement("div");
                                postCard.classList.add("card", "post-card");
                                postCard.innerHTML = `
                    <div class="card-body">
                        <span class="post-number">${postCount}</span>
                        <h5 class="card-title">${post.Title}</h5>
                        ${videoEmbed ? videoEmbed : `<div class="card-text">${post.ContentBody}</div>`}
                        ${downloadLink}
                    </div>
                `;
                                console.log("Created postCard for post ID:", post.ContentID);

                                // Ensure no content inside the card has 'contenteditable'
                                const editableElems = postCard.querySelectorAll('[contenteditable]');
                                editableElems.forEach(elem => {
                                    elem.removeAttribute('contenteditable');
                                });

                                // Remove any <input> elements inside the post
                                const inputs = postCard.querySelectorAll('input');
                                inputs.forEach(input => input.remove());

                                postsContainer.appendChild(postCard);
                                console.log("Appended postCard to postsContainer.");
                            } else {
                                console.warn(`Duplicate post with ID ${post.ContentID} skipped.`);
                            }
                        });

                        initializeVideoTracking();
                        page++;
                        console.log("Incremented page to:", page);
                    }
                })
                .catch(error => {
                    console.error("Error fetching posts:", error);
                })
                .finally(() => {
                    isLoading = false;
                    loadingIndicator.style.display = "none";
                    console.log("Finished processing posts, isLoading set to false.");
                });
        }


        function initializeVideoTracking() {
            // Load YouTube API if not already loaded
            if (document.querySelector("iframe[src*='youtube.com']") && !window.YT) {
                const script = document.createElement("script");
                script.src = "https://www.youtube.com/iframe_api";
                script.onload = () => {
                    setupYouTubeTracking(); // Ensure tracking is set up once API loads
                };
                document.body.appendChild(script);
            } else if (window.YT && YT.Player) {
                setupYouTubeTracking(); // If already loaded, initialize tracking immediately
            }

            // Load Vimeo API if not already loaded
            if (document.querySelector("iframe[src*='vimeo.com']") && !window.Vimeo) {
                const script = document.createElement("script");
                script.src = "https://player.vimeo.com/api/player.js";
                script.onload = () => setupVimeoTracking();
                document.body.appendChild(script);
            } else {
                setupVimeoTracking();
            }
        }

        // Ensure YouTube API callback runs AFTER new iframes are added
        function onYouTubeIframeAPIReady() {
            setupYouTubeTracking();
        }

        // YouTube tracking setup: start the session on play and update every 5 seconds.
        function setupYouTubeTracking() {
            document.querySelectorAll("iframe[src*='youtube.com']").forEach((iframe) => {
                if (!iframe.dataset.youtubeInitialized) {
                    // Ensure each iframe has a unique id for tracking.
                    if (!iframe.id) {
                        iframe.id = "yt-player-" + Math.random().toString(36).substr(2, 9);
                    }
                    console.log(`Initializing YouTube Player for: ${iframe.src}`);

                    new YT.Player(iframe, {
                        events: {
                            'onStateChange': function (event) {
                                var playerId = event.target.getIframe().id;
                                var contentId = iframe.dataset.contentid;
                                if (event.data === YT.PlayerState.PLAYING) {
                                    console.log("User started watching YouTube video:", event.target.getVideoUrl());
                                    // Start the watch session if it hasn't been started already.
                                    startWatching(contentId);
                                    // Start an interval if one isn't already running.
                                    if (!youtubeIntervals[playerId]) {
                                        youtubeIntervals[playerId] = setInterval(function () {
                                            var currentTime = event.target.getCurrentTime();
                                            console.log(`YouTube [${playerId}] current time: ${Math.floor(currentTime)} seconds`);
                                            updateWatching(contentId, Math.floor(currentTime));
                                        }, 5000); // Update every 5 seconds.
                                    }
                                } else {
                                    // Clear the interval when video is paused, buffering, or ended.
                                    if (youtubeIntervals[playerId]) {
                                        clearInterval(youtubeIntervals[playerId]);
                                        delete youtubeIntervals[playerId];
                                    }
                                }
                            }
                        }
                    });

                    iframe.dataset.youtubeInitialized = "true"; // Prevent re-initialization.
                }
            });
        }

        // Vimeo tracking setup: start session on play and throttle updates to every 5 seconds.
        function setupVimeoTracking() {
            document.querySelectorAll("iframe[src*='vimeo.com']").forEach(iframe => {
                if (!iframe.dataset.vimeoInitialized) {
                    const player = new Vimeo.Player(iframe);
                    player.on('play', function () {
                        console.log("User started watching Vimeo video:", iframe.src);
                        var contentId = iframe.dataset.contentid;
                        startWatching(contentId);
                    });
                    player.on('timeupdate', function (data) {
                        console.log(`Vimeo [${iframe.src}] current time: ${Math.floor(data.seconds)} seconds (duration: ${data.duration} seconds)`);
                        var contentId = iframe.dataset.contentid;
                        // Throttle: only update every 5 seconds.
                        var lastUpdate = iframe.dataset.lastUpdate ? parseFloat(iframe.dataset.lastUpdate) : 0;
                        if (data.seconds - lastUpdate >= 5) {
                            iframe.dataset.lastUpdate = data.seconds;
                            updateWatching(contentId, Math.floor(data.seconds));
                        }
                    });
                    iframe.dataset.vimeoInitialized = "true"; // Prevent re-initialization.
                }
            });
        }

        // Call this when the video starts playing.
        function startWatching(contentId) {
            // If no session exists for this content, create one.
            if (!watchSessions[contentId]) {
                const data = {
                    contentId: contentId,
                    startTime: new Date().toISOString(),
                    watchedSeconds: 0
                };
                fetch("/api/VideoWatch/Start", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    credentials: "include",
                    body: JSON.stringify(data)
                })
                .then(response => response.json())
                .then(result => {
                    console.log("Started watch session:", result);
                    watchSessions[contentId] = result.videoWatchID;
                })
                .catch(error => console.error("Error starting watch session:", error));
            }
        }

        // Call this to update the existing watch session.
        function updateWatching(contentId, watchedSeconds) {
            console.log("updateWatching called for contentId:", contentId, "with watchedSeconds:", watchedSeconds);
            console.log("watch sessions: ", watchSessions)
            if (watchSessions[contentId]) {
                console.log("Found watch session ID:", watchSessions[contentId]);
                const data = {
                    watchedSeconds: watchedSeconds
                };
                fetch(`/api/VideoWatch/Update/${watchSessions[contentId]}`, {
                    method: "PUT",
                    headers: { "Content-Type": "application/json" },
                    credentials: "include",
                    body: JSON.stringify(data)
                })
                .then(response => response.json())
                .then(result => {
                    console.log("Updated watch session:", result);
                })
                .catch(error => console.error("Error updating watch session:", error));
            }
        }

        /**
         * Fallback scroll event if IntersectionObserver isn't supported.
         */
        function onScroll() {
            const scrollPosition = window.innerHeight + window.scrollY;
            const pageHeight = document.documentElement.scrollHeight;
            if (scrollPosition >= pageHeight - 50) {
                loadPosts();
            }
        }

        let observer;
        document.addEventListener("DOMContentLoaded", function () {
            if ('IntersectionObserver' in window) {
                observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            console.log("Sentinel is in view. Loading more posts...");
                            loadPosts();
                        }
                    });
                }, {
                    rootMargin: "50px"  // Trigger loading before the sentinel is fully visible
                });
                observer.observe(sentinel);
            } else {
                window.addEventListener("scroll", onScroll);
            }

            // Load the first batch of posts immediately.
            loadPosts();
        });
    </script>
</body>
</html>
